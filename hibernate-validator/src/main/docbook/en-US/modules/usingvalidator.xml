<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ Hibernate, Relational Persistence for Idiomatic Java
  ~
  ~ Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  ~ indicated by the @author tags or express copyright attribution
  ~ statements applied by the authors.  All third-party contributions are
  ~ distributed under license by Red Hat Middleware LLC.
  ~
  ~ This copyrighted material is made available to anyone wishing to use, modify,
  ~ copy, or redistribute it subject to the terms and conditions of the GNU
  ~ Lesser General Public License, as published by the Free Software Foundation.
  ~
  ~ This program is distributed in the hope that it will be useful,
  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  ~ or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  ~ for more details.
  ~
  ~ You should have received a copy of the GNU Lesser General Public License
  ~ along with this distribution; if not, write to:
  ~ Free Software Foundation, Inc.
  ~ 51 Franklin Street, Fifth Floor
  ~ Boston, MA  02110-1301  USA
  -->
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="validator-usingvalidator">
  <title>Validation step by step</title>

  <para>In this chapter we will see in more detail how to use Bean Validation
  to validate constraints for a given entity model. We will also learn which
  default constraints the specification provides and which additional
  constraints are only provided by Hibernate Validator. Let's start with how
  to add constraints to an entity.</para>

  <section id="validator-usingvalidator-annotate" revision="1">
    <title>Defining constraints</title>

    <para>Constraints in Bean Validation are expressed via Java annotations.
    In this section we show how to annotate an object model with these
    annotations. We have to differentiate between three different type of
    constraint annotations - class-, field- and property-level
    annotations.</para>

    <note>
      <para>Not all constraints can be placed on any of these levels. In fact
      all the default constraints defined by Bean Validation cannot be places
      at class level. The java.lang.annotation.Target annotation placed on the
      constraint annotation itself determines on which elements a constraint
      can be placed. See also <xref
      linkend="validator-customconstraints" /></para>
    </note>

    <section>
      <title id="validator-usingvalidator-classlevel">Class-level
      constraints</title>

      <para>When a constraint annotation is placed on class level the class
      instance itself passed to the
      <classname>ConstraintValidator</classname>. Class level constraints are
      useful if it is necessary to inspect more than a single property of the
      class to validate it or if a correlation between different state
      variables has to be evaluated. In the following example we add the
      properties <property>horsePower</property> and
      <property>kiloWatt</property> to the class <classname>Car</classname>.
      We also add the constraint ValidCar to the class itself. We will later
      see how we can actually create this custom constraint (see <xref
      linkend="validator-customconstraints" />). For now we can just assume
      that this constraints will for example ensure that the value for
      <property>kiloWatt</property> is 0.7456 *
      <property>horsePower</property>.</para>

      <para><example xreflabel="Car-example">
          <title>Class Car with added horsePower and killoWatt
          properties</title>

          <programlisting language="Java">package com.mycompany;

import javax.validation.constraints.Min;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

<emphasis role="bold">@ValidCar</emphasis>
public class Car {

    <emphasis role="bold">@NotNull</emphasis>
    private String manufacturer;

    <emphasis role="bold">@NotNull</emphasis>
    <emphasis role="bold">@Size(min = 2, max = 14)</emphasis>
    private String licensePlate;

    <emphasis role="bold">@Min(2)</emphasis>
    private int seatCount;

    private int horsePower;

    private double kiloWatt;
    
    public Car(String manufacturer, String licencePlate, int seatCount) {
        this.manufacturer = manufacturer;
        this.licensePlate = licencePlate;
        this.seatCount = seatCount;
    }

    //getters and setters ...
}</programlisting>
        </example></para>
    </section>

    <section>
      <title>Field-level constraints</title>

      <para>Constraints can also be expressed by annotating a field of a
      class. The following listing shows a simple example:</para>

      <example>
        <title>Example for field level constraints</title>

        <programlisting>package com.mycompany;

import javax.validation.constraints.NotNull;

public class Car {

    <emphasis role="bold">@NotNull</emphasis>
    private String manufacturer;

    public Car(String manufacturer) {
        this.manufacturer = manufacturer;
    }
}</programlisting>
      </example>

      <para>When using field level constraints field access strategy is used
      to access the value to be value. This means the bean validation provider
      accesses the instance variable directly.</para>
    </section>

    <section>
      <title>Property-level constraints</title>

      <para>If your model class adheres to the <ulink type=""
      url="http://java.sun.com/javase/technologies/desktop/javabeans/index.jsp">JavaBeans</ulink>
      standard, it is also possible to annotate the properties of a bean class
      instead of its fields. <note>
          <para>The property's getter method has to be annotated, not its
          setter.</para>
        </note></para>

      <example>
        <title>Example for property level constraints</title>

        <programlisting>package com.mycompany;

import javax.validation.constraints.AssertTrue;
import javax.validation.constraints.NotNull;

public class Car {

    private String manufacturer;

    private boolean isRegistered;
      
    public Car(String manufacturer, boolean isRegistered) {
        super();
        this.manufacturer = manufacturer;
        this.isRegistered = isRegistered;
    }

    <emphasis role="bold">@NotNull</emphasis>
    public String getManufacturer() {
        return manufacturer;
    }

    public void setManufacturer(String manufacturer) {
        this.manufacturer = manufacturer;
    }

    <emphasis role="bold">@AssertTrue</emphasis>
    public boolean isRegistered() {
        return isRegistered;
    }

    public void setRegistered(boolean isRegistered) {
        this.isRegistered = isRegistered;
    }
}</programlisting>
      </example>

      <para>When using property level constraints property access strategy is
      used to access the value to be validated. This means the bean validation
      provider accesses the state via the property accessor method. </para>

      <para>Generally it is recommended to stick either to field
      <emphasis>or</emphasis> property annotation within one class. It is not
      recommended to annotate a field <emphasis>and</emphasis> the
      accompanying getter method as this would cause the field to be validated
      twice.</para>
    </section>

    <section>
      <title>Constraint inheritance</title>

      <para>When validating an object that implements an interface or extends
      another class, all constraint annotations on the implemented interface
      and parent class apply in the same manner as the constraints specified
      on the validated object itself. To make things clearer let's have a look
      at the following example:</para>

      <example>
        <title>Example for constraint inheritance using RentalCar</title>

        <programlisting>package com.mycompany;

import javax.validation.constraints.NotNull;

public class RentalCar extends Car {

    private String rentalStation;
    
    public RentalCar(String manufacturer, String rentalStation) {
        super(manufacturer);
        this.rentalStation = rentalStation;
    }
    
    @NotNull
    public String getRentalStation() {
        return rentalStation;
    }

    public void setRentalStation(String rentalStation) {
        this.rentalStation = rentalStation;
    }
}</programlisting>
      </example>

      <para>Our well-known class <classname>Car</classname> from <link
      linkend="example-class-car">the getting started section</link> is now
      extended by <classname>RentalCar</classname> with the additional
      property <property>rentalStation</property>. If an instance of
      <classname>RentalCar</classname> is validated, not only the
      <classname>@NotNull</classname> constraint on
      <property>rentalStation</property> would be validated, but also the
      constraint at <property>manufacturer</property> from the parent
      class.</para>

      <para>The same would hold true, if <classname>Car</classname> was an
      interface, that is implemented by
      <classname>RentalCar</classname>.</para>

      <para>Constraint annotations are aggregated if methods are overridden.
      If <classname>RentalCar</classname> would override the
      <methodname>getManufacturer()</methodname> method from
      <classname>Car</classname> any constraints annotated at the overriding
      method would be evaluated in addition to the
      <classname>@NotNull</classname> constraint from the super-class.</para>
    </section>

    <section>
      <title>Object graphs</title>

      <para>The Bean Validation API does not only allow to validate single
      objects but also complete object graphs. To do so just annotate a field
      or property representing a reference to another object with
      <classname>@Valid</classname>. If the parent object is validated, all
      objects referenced by a field/property annotated with
      <classname>@Valid</classname> will be validated as well (as will be
      their children etc.). The following shows a simple example:</para>

      <example>
        <title>Class Person</title>

        <programlisting>
package com.mycompany;

import javax.validation.constraints.NotNull;

public class Person {

    @NotNull
    private String name;
    
    public Person(String name) {
        super();
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}</programlisting>
      </example>

      <example>
        <title>Adding a driver to the car</title>

        <programlisting>package com.mycompany;

import javax.validation.Valid;
import javax.validation.constraints.NotNull;

public class Car {

    @NotNull
    @Valid
    private Person driver;
    
    public Car(Person driver) {
        this.driver = driver;
    }

    //getters and setters ...
}</programlisting>
      </example>

      <para>If an instance of <classname>Car</classname> is validated, the
      referenced <classname>Person</classname> object will be validated as
      well, as the <property>driver</property> field is annotated with
      <classname>@Valid</classname>. Therefore the validation of a
      <classname>Car</classname> will fail if the <property>name</property>
      field of the referenced <classname>Person</classname> instance is
      <code>null</code>.</para>

      <para>Object graph validation also works for collection-typed fields.
      That means any attributes that are</para>

      <itemizedlist>
        <listitem>
          <para>arrays</para>
        </listitem>

        <listitem>
          <para>implement <classname>java.lang.Iterable</classname>
          (especially <classname>Collection</classname>,
          <classname>List</classname> and <classname>Set</classname>)</para>
        </listitem>

        <listitem>
          <para>implement <classname>java.util.Map</classname></para>
        </listitem>
      </itemizedlist>

      <para>can be annotated with <classname>@Valid</classname>, which will
      cause each contained element to be validated, when the parent object is
      validated.</para>

      <example>
        <title>Car with a list of passengers</title>

        <programlisting>package com.mycompany;

import java.util.ArrayList;
import java.util.List;

import javax.validation.Valid;
import javax.validation.constraints.Min;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

import org.hibernate.validator.constraints.NotEmpty;

public class Car {

    @NotNull
    @Valid
    private List&lt;Person&gt; passengers = new ArrayList&lt;Person&gt;();

    public Car(List&lt;Person&gt; passengers) {
        this.passengers = passengers;
    }

    //getters and setters ...
}</programlisting>
      </example>

      <para>If a <classname>Car</classname> instance is validated now, a
      <classname>ConstraintValidation</classname> will be created, if any of
      the <classname>Person</classname> objects contained in the
      <property>passengers</property> list has a <code>null</code> name.<note>
          <para><classname>null</classname> values are getting ignored when
          validating object graphs. </para>
        </note></para>
    </section>
  </section>

  <section id="validator-usingvalidator-validate" revision="1">
    <title>Validating constraints</title>

    <para>The <classname>Validator</classname> interface is the main entry
    point to Bean Validation. In the following we first will show how to
    obtain an <classname>Validator</classname> instance using the different
    bootstrapping mechanisms. Afterwards we will learn how to use the
    different methods of the <classname>Validator</classname>
    interface.</para>

    <section>
      <title>Obtaining a Validator instance</title>

      <para>The first step towards validating a class instance is to get hold
      of a <classname>Validator</classname> instance. The road to this
      instance leads via the <classname>Validation</classname> class and a
      <classname>ValidatorFactory</classname>. The by far easiest way is to
      use the static
      <methodname>Validation.buildDefaultValidatorFactory()</methodname>
      method:<programlisting>ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
Validator validator = factory.getValidator();</programlisting>You can also use
      the method <methodname>Validation.byDefaultProvider()</methodname> which
      will allow you to configure several aspects of the created Validator
      instance:<programlisting>Configuration&lt;?&gt; config = Validation.byDefaultProvider().configure();
config.messageInterpolator(new MyMessageInterpolator())
    .traversableResolver( new MyTraversableResolver())
    .constraintValidatorFactory(new MyConstraintValidatorFactory());

ValidatorFactory factory = config.buildValidatorFactory();
Validator validator = factory.getValidator();
</programlisting>We will learn more about
      <classname>MessageInterpolator</classname> and
      <classname>TraversableResolver</classname> in later chapters. </para>

      <para>Last but not least you can ask for a Configuration object of a
      specific Bean Validation provider. This is useful if you have more than
      one Bean Validation provider in your classpath. In this situation you
      can make an explicit choice about which implementation to use. In the
      case of Hibernate Validator the Validator creation looks
      like:<programlisting>ValidatorConfiguration configuration = Validation.byProvider( HibernateValidator.class )
config.messageInterpolator(new MyMessageInterpolator())
    .traversableResolver( new MyTraversableResolver())
    .constraintValidatorFactory(new MyConstraintValidatorFactory());

ValidatorFactory factory = config.buildValidatorFactory();
Validator validator = factory.getValidator();</programlisting></para>

      <para><note>
          <para>The generated <classname>Validator</classname> instance is
          thread safe and can be cached.</para>
        </note>Now that we have a <classname>Validator</classname> instance,
      let's see how we can use it to validate class instances.</para>
    </section>

    <section>
      <title>Validator methods</title>

      <para>The <classname>Validator</classname> interface contains three
      methods that can be used to validate entire objects or only single
      object properties.</para>

      <para>All of these methods return a
      <classname>Set&lt;ConstraintViolation&gt;</classname>, which will be
      empty, if the validation succeeded. Otherwise a
      <classname>ConstraintViolation</classname> object for each violated
      constraint will be contained.</para>

      <para>All the validation methods have a var-args parameter which can be
      used to specify, which validation groups shall be considered when
      performing the validation. If the parameter is not specified (as in the
      following examples) the default validation group will be used. We will
      go into more detail on the topic of validation groups in the <link
      linkend="validator-usingvalidator-validationgroups">following
      section</link>.</para>

      <section>
        <title>validate()</title>

        <para>Use the <methodname>validate()</methodname> method to perform
        validation of all constraints of a given object. The following listing
        shows an example:</para>

        <programlisting>ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
Validator validator = factory.getValidator();

Car car = new Car(null);

Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations =
    validator.validate(car);

assertEquals(1, constraintViolations.size());
assertEquals(
    "may not be null", constraintViolations.iterator().next().getMessage());</programlisting>
      </section>

      <section>
        <title>validateProperty()</title>

        <para>With help of the <methodname>validateProperty()</methodname> a
        single named property of a given object can be validated:</para>

        <programlisting>Validator validator = Validation.buildDefaultValidatorFactory().getValidator();

Car car = new Car(null);

Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations =
    validator.validateProperty(car, "manufacturer");

assertEquals(1, constraintViolations.size());
assertEquals(
    "may not be null", constraintViolations.iterator().next().getMessage());</programlisting>
      </section>

      <section>
        <title>validateValue()</title>

        <para>Using the <methodname>validateValue() </methodname>method you
        can check, whether a single property of a given class can be validated
        successfully, if the property had the specified value:</para>

        <programlisting>Validator validator = Validation.buildDefaultValidatorFactory().getValidator();

Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations =
    validator.validateValue(Car.class, "manufacturer", null);

assertEquals(1, constraintViolations.size());
assertEquals(
    "may not be null", constraintViolations.iterator().next().getMessage());</programlisting>
      </section>

      <section>
        <title>getConstraintsForClass()</title>

        <para>TODO</para>
      </section>
    </section>

    <section>
      <title>Working with ConstraintViolations</title>

      <para>TODO: Message interpolation?</para>
    </section>
  </section>

  <section id="validator-usingvalidator-validationgroups" revision="1">
    <title>Using groups</title>

    <para></para>

    <section revision="1">
      <title>Group sequences</title>

      <para></para>
    </section>
  </section>

  <section id="validator-defineconstraints-builtin" revision="2">
    <title>Built-in constraints</title>

    <para>Hibernate Validator comes with some built-in constraints, which
    covers most basic data checks. As we'll see later, you're not limited to
    them, you can literally in a minute write your own constraints.</para>

    <table>
      <title>Built-in constraints</title>

      <tgroup cols="4">
        <colspec align="center" />

        <thead>
          <row>
            <entry>Annotation</entry>

            <entry>Apply on</entry>

            <entry>Runtime checking</entry>

            <entry>Hibernate Metadata impact</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>@Length(min=, max=)</entry>

            <entry>property (String)</entry>

            <entry>check if the string length match the range</entry>

            <entry>Column length will be set to max</entry>
          </row>

          <row>
            <entry>@Max(value=)</entry>

            <entry>property (numeric or string representation of a
            numeric)</entry>

            <entry>check if the value is less than or equals to max</entry>

            <entry>Add a check constraint on the column</entry>
          </row>

          <row>
            <entry>@Min(value=)</entry>

            <entry>property (numeric or string representation of a
            numeric)</entry>

            <entry>check if the value is more than or equals to min</entry>

            <entry>Add a check constraint on the column</entry>
          </row>

          <row>
            <entry>@NotNull</entry>

            <entry>property</entry>

            <entry>check if the value is not null</entry>

            <entry>Column(s) are not null</entry>
          </row>

          <row>
            <entry>@NotEmpty</entry>

            <entry>property</entry>

            <entry>check if the string is not null nor empty. Check if the
            connection is not null nor empty</entry>

            <entry>Column(s) are not null (for String)</entry>
          </row>

          <row>
            <entry>@Past</entry>

            <entry>property (date or calendar)</entry>

            <entry>check if the date is in the past</entry>

            <entry>Add a check constraint on the column</entry>
          </row>

          <row>
            <entry>@Future</entry>

            <entry>property (date or calendar)</entry>

            <entry>check if the date is in the future</entry>

            <entry>none</entry>
          </row>

          <row>
            <entry>@Pattern(regex="regexp", flag=) or @Patterns(
            {@Pattern(...)} )</entry>

            <entry>property (string)</entry>

            <entry>check if the property match the regular expression given a
            match flag (see <classname>java.util.regex.Pattern </classname>
            )</entry>

            <entry>none</entry>
          </row>

          <row>
            <entry>@Range(min=, max=)</entry>

            <entry>property (numeric or string representation of a
            numeric)</entry>

            <entry>check if the value is between min and max
            (included)</entry>

            <entry>Add a check constraint on the column</entry>
          </row>

          <row>
            <entry>@Size(min=, max=)</entry>

            <entry>property (array, collection, map)</entry>

            <entry>check if the element size is between min and max
            (included)</entry>

            <entry>none</entry>
          </row>

          <row>
            <entry>@AssertFalse</entry>

            <entry>property</entry>

            <entry>check that the method evaluates to false (useful for
            constraints expressed in code rather than annotations)</entry>

            <entry>none</entry>
          </row>

          <row>
            <entry>@AssertTrue</entry>

            <entry>property</entry>

            <entry>check that the method evaluates to true (useful for
            constraints expressed in code rather than annotations)</entry>

            <entry>none</entry>
          </row>

          <row>
            <entry>@Valid</entry>

            <entry>property (object)</entry>

            <entry>perform validation recursively on the associated object. If
            the object is a Collection or an array, the elements are validated
            recursively. If the object is a Map, the value elements are
            validated recursively.</entry>

            <entry>none</entry>
          </row>

          <row>
            <entry>@Email</entry>

            <entry>property (String)</entry>

            <entry>check whether the string is conform to the email address
            specification</entry>

            <entry>none</entry>
          </row>

          <row>
            <entry>@CreditCardNumber</entry>

            <entry>property (String)</entry>

            <entry>check whether the string is a well formated credit card
            number (derivative of the Luhn algorithm)</entry>

            <entry>none</entry>
          </row>

          <row>
            <entry>@Digits</entry>

            <entry>property (numeric or string representation of a
            numeric)</entry>

            <entry>check whether the property is a number having up to
            <literal>integerDigits</literal> integer digits and
            <literal>fractionalDigits</literal> fractonal digits</entry>

            <entry>define column precision and scale</entry>
          </row>

          <row>
            <entry>@EAN</entry>

            <entry>property (string)</entry>

            <entry>check whether the string is a properly formated EAN or
            UPC-A code</entry>

            <entry>none</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
  </section>
</chapter>
