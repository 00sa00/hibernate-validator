<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ Hibernate, Relational Persistence for Idiomatic Java
  ~
  ~ Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  ~ indicated by the @author tags or express copyright attribution
  ~ statements applied by the authors.  All third-party contributions are
  ~ distributed under license by Red Hat Middleware LLC.
  ~
  ~ This copyrighted material is made available to anyone wishing to use, modify,
  ~ copy, or redistribute it subject to the terms and conditions of the GNU
  ~ Lesser General Public License, as published by the Free Software Foundation.
  ~
  ~ This program is distributed in the hope that it will be useful,
  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  ~ or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  ~ for more details.
  ~
  ~ You should have received a copy of the GNU Lesser General Public License
  ~ along with this distribution; if not, write to:
  ~ Free Software Foundation, Inc.
  ~ 51 Franklin Street, Fifth Floor
  ~ Boston, MA  02110-1301  USA
  -->
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="validator-checkconstraints">
  <title>Integration with other frameworks</title>

  <para>Hibernate Validator is intended to be used to implement multi-layered
  data validation, where constraints are expressed in a single place (the
  annotated domain model) and checked in various different layers of the
  application.</para>

  <para>This chapter will cover Hibernate Validator usage for different
  layers</para>

  <section id="validator-checkconstraints-db" revision="2">
    <title>Database schema-level validation</title>

    <para>Out of the box, Hibernate Annotations will translate the constraints
    you have defined for your entities into mapping metadata. For example, if
    a property of your entity is annotated <literal>@NotNull</literal>, its
    columns will be declared as <literal>not null</literal> in the DDL schema
    generated by Hibernate.</para>

    <para>Using hbm2ddl, domain model constraints will be expressed into the
    database schema.</para>

    <para>If, for some reason, the feature needs to be disabled, set
    <literal>hibernate.validator.apply_to_ddl</literal> to
    <literal>false</literal>. See also <xref
    linkend="table-builtin-constraints" /></para>
  </section>

  <section id="validator-checkconstraints-orm">
    <title>ORM integration</title>

    <para>Hibernate Validator integrates with both Hibernate and all pure Java
    Persistence providers.</para>

    <section id="validator-checkconstraints-orm-hibernateevent" revision="1">
      <title>Hibernate event-based validation</title>

      <para>Hibernate Validator has a built-in Hibernate event listener -
      <classname>org.hibernate.cfg.beanvalidation.BeanValidationEventListener</classname>
      - which is part of Hibernate Annotations. Whenever a
      <literal>PreInsertEvent</literal> or <literal>PreUpdateEvent</literal>
      occurs, the listener will verify all constraints of the entity instance
      and throw an exception if any constraint is violated. Basically, objects
      will be checked before any inserts and before any updates are made by
      Hibernate. This includes changes applied by cascade! This is the most
      convenient and the easiest way to activate the validation process. On
      constraint violation, the event will raise a runtime
      <classname>ConstraintViolationException</classname> which contains a set
      of <literal>ConstraintViolation</literal>s describing each
      failure.</para>

      <para>If Hibernate Validator is present in the classpath, Hibernate
      Annotations (or Hibernate EntityManager) will use it transparently. If,
      for some reason, you want to disable this integration, set
      <literal>hibernate.validator.autoregister_listeners</literal> to
      false</para>

      <para><note>
          <para>If the beans are not annotated with validation annotations,
          there is no runtime performance cost.</para>
        </note></para>

      <para>In case you need to manually set the event listeners for Hibernate
      Core, use the following configuration in
      <literal>hibernate.cfg.xml</literal>:</para>

      <programlisting>&lt;hibernate-configuration&gt;
    ...
    &lt;event type="pre-update"&gt;
        &lt;listener 
          class="<classname>org.hibernate.cfg.beanvalidation.BeanValidationEventListener</classname>"/&gt;
    &lt;/event&gt;
    &lt;event type="pre-insert"&gt;
        &lt;listener 
          class="<classname>org.hibernate.cfg.beanvalidation.BeanValidationEventListener</classname>"/&gt;
    &lt;/event&gt;
&lt;/hibernate-configuration&gt;</programlisting>
    </section>

    <section id="validator-checkconstraints-orm-jpaevent">
      <title>Java Persistence event-based validation</title>

      <para>Hibernate Validator is not tied to Hibernate for event based
      validation: a Java Persistence entity listener is available. Whenever an
      listened entity is persisted or updated, Hibernate Validator will verify
      all constraints of the entity instance and throw an exception if any
      constraint is violated. Basically, objects will be checked before any
      inserts and before any updates made by the Java Persistence provider.
      This includes changes applied by cascade! On constraint violation, the
      event will raise a runtime <classname>InvalidStateException</classname>
      which contains an array of <literal>InvalidValue</literal>s describing
      each failure.</para>

      <para>Here is how to make a class validatable:</para>

      <programlisting>@Entity
@EntityListeners( JPAValidateListener.class )
public class Submarine {
    ...
}</programlisting>

      <para><note>
          <para>Compared to the Hibernate event, the Java Persistence listener
          has two drawbacks. You need to define the entity listener on every
          validatable entity. The DDL generated by your provider will not
          reflect the constraints.</para>
        </note></para>
    </section>
  </section>

  <section>
    <title>Presentation layer validation</title>

    <para>When working with JSF and <productname>JBoss Seam</productname>, one
    can triggers the validation process at the presentation layer using Seam's
    JSF tags <literal>&lt;s:validate&gt;</literal> and
    <literal>&lt;s:validateAll/&gt;</literal>, letting the constraints be
    expressed on the model, and the violations presented in the view</para>

    <programlisting>&lt;h:form&gt;
    &lt;div&gt;
        &lt;h:messages/&gt;
    &lt;/div&gt;
    <emphasis role="bold">&lt;s:validateAll&gt;</emphasis>
        &lt;div&gt;
            Country:
            &lt;h:inputText value="#{location.country}" required="true"/&gt;
        &lt;/div&gt;
        &lt;div&gt;
            Zip code:
            &lt;h:inputText value="#{location.zip}" required="true"/&gt;
        &lt;/div&gt;
        &lt;div&gt;
            &lt;h:commandButton/&gt;
        &lt;/div&gt;
    <emphasis role="bold">&lt;/s:validateAll&gt;</emphasis>
&lt;/h:form&gt;</programlisting>

    <para>Going even further, and adding <productname>Ajax4JSF</productname>
    to the loop will bring client side validation with just a couple of
    additional JSF tags, again without validation definition
    duplication.</para>

    <para>Check the <ulink url="http://www.jboss.com/products/seam">JBoss
    Seam</ulink> documentation for more information.</para>
  </section>
</chapter>
