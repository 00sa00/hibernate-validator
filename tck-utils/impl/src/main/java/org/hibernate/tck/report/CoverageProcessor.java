package org.hibernate.tck.report;import static javax.lang.model.SourceVersion.RELEASE_6;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.util.ArrayList;import java.util.List;import java.util.Map;import java.util.Set;import javax.annotation.processing.AbstractProcessor;import javax.annotation.processing.ProcessingEnvironment;import javax.annotation.processing.RoundEnvironment;import javax.annotation.processing.SupportedAnnotationTypes;import javax.annotation.processing.SupportedSourceVersion;import javax.lang.model.element.AnnotationMirror;import javax.lang.model.element.AnnotationValue;import javax.lang.model.element.Element;import javax.lang.model.element.ExecutableElement;import javax.lang.model.element.TypeElement;import org.hibernate.tck.annotations.SpecAssertion;import org.hibernate.tck.annotations.SpecAssertions;/** * Annotation processor for generating TCK coverage report * * @author Shane Bryzak * @author Hardy Ferentschik */@SupportedAnnotationTypes({        "org.hibernate.tck.annotations.SpecAssertion",         "org.hibernate.tck.annotations.SpecAssertions"})@SupportedSourceVersion(RELEASE_6)public class CoverageProcessor extends AbstractProcessor {    private static final String OUTDIR_OPTION_FLAG = "outputDir";    private static final String AUDITFILE_OPTION_KEY = "auditXml";    private static final String REPORT_FILE_NAME = "coverage.html";    private static final String DEFAULT_AUDIT_FILE_NAME = "tck-audit.xml";    private final List<SpecReference> references = new ArrayList<SpecReference>();    private AuditParser auditParser;    private File baseDir;    public CoverageProcessor() {    }    public void init(ProcessingEnvironment env) {        super.init(env);                createOutputDir();        InputStream in = getAuditFileInputStream();        if (in == null) {            return;        }        try {            auditParser = new AuditParser(in);            auditParser.parse();        }        catch (Exception e) {            throw new RuntimeException("Unable to parse audit file.");        }    }    private InputStream getAuditFileInputStream() {        InputStream in;        String auditFileName = processingEnv.getOptions().get(AUDITFILE_OPTION_KEY);                if (auditFileName == null || auditFileName.length() == 0) {            auditFileName = getCurrentWorkingDirectory() + DEFAULT_AUDIT_FILE_NAME;            System.out.println(                    "No audit file specified. Trying default: " + auditFileName            );        }        else        {           System.out.println(              "Reading spec assertions from audit file: " + auditFileName);        }        try {            in = new FileInputStream(auditFileName);        }        catch (IOException ex) {           System.err.println("Unable to open audit file - " + auditFileName);           System.err.println("No report generated");            return null;        }        return in;    }    private void createOutputDir() {        String baseDirName = processingEnv.getOptions().get(OUTDIR_OPTION_FLAG);        // I would like to get the baseDir as property, but it seems that the maven compiler plugin still has issues - http://jira.codehaus.org/browse/MCOMPILER-75        if (baseDirName == null) {            baseDirName = getCurrentWorkingDirectory() + "target";           System.out.println(                    "No output directory specided using " + baseDirName + " instead."            );        }        else        {           System.out.println(                 "Outputting to " + baseDirName         );        }        baseDir = new File(baseDirName);        baseDir.mkdirs();    }    private String getCurrentWorkingDirectory() {        return System.getProperty("user.dir") + System.getProperty("file.separator");    }    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnvironment) {        if (auditParser == null) {            return true;        }        for (TypeElement type : annotations) {            processAnnotatedMethods(roundEnvironment, type);        }        if (roundEnvironment.processingOver()) {            new CoverageReport(references, auditParser).writeToFile(new File(baseDir, REPORT_FILE_NAME));        }        return true;    }    private void processAnnotatedMethods(RoundEnvironment env, TypeElement annotation) {        Set<Element> elements = (Set<Element>) env.getElementsAnnotatedWith(annotation);        for (Element element : elements) {            processMethod(element);        }    }    private void processMethod(Element element) {        ExecutableElement methodElement = (ExecutableElement) element;        String annotationType = null;        for (AnnotationMirror annotationMirror : processingEnv.getElementUtils().getAllAnnotationMirrors(methodElement)) {            Map<? extends ExecutableElement, ? extends AnnotationValue> annotationParameters =                    processingEnv.getElementUtils().getElementValuesWithDefaults(annotationMirror);            annotationType = annotationMirror.getAnnotationType().toString();            if (annotationType.equals(SpecAssertions.class.getName())) {                List<AnnotationMirror> mirrors = (List<AnnotationMirror>) annotationMirror.getElementValues().values().iterator().next().getValue();                for (AnnotationMirror mirror : mirrors) {                    createSpecReference(methodElement, processingEnv.getElementUtils().getElementValuesWithDefaults(mirror));                }            } else if (annotationType.equals(SpecAssertion.class.getName())) {                createSpecReference(methodElement, annotationParameters);            }        }    }    private void createSpecReference(ExecutableElement methodElement,           Map<? extends ExecutableElement, ? extends AnnotationValue> annotationParameters) {               SpecReference ref = new SpecReference();        ref.setClassName(methodElement.getClass().getName());        ref.setMethodName(methodElement.getSimpleName().toString());        for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> entry : annotationParameters.entrySet()) {            final String elementKey = entry.getKey().toString();                        if (elementKey.equals("section()")) {                ref.setSection((String) entry.getValue().getValue());            } else if (elementKey.equals("id()")) {                ref.setAssertion((String) entry.getValue().getValue());            }        }        references.add(ref);    }}