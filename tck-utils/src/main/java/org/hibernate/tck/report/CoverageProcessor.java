package org.hibernate.tck.report;import org.hibernate.tck.annotations.SpecAssertion;import org.hibernate.tck.annotations.SpecAssertions;import javax.annotation.processing.*;import static javax.lang.model.SourceVersion.RELEASE_6;import javax.lang.model.element.*;import javax.tools.Diagnostic;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.util.ArrayList;import java.util.List;import java.util.Map;import java.util.Set;/** * Annotation processor for generating TCK coverage report * * @author Shane Bryzak * @author Hardy Ferentschik */@SupportedAnnotationTypes({        "org.hibernate.tck.annotations.SpecAssertion", "org.hibernate.tck.annotations.SpecAssertions"})@SupportedSourceVersion(RELEASE_6)public class CoverageProcessor extends AbstractProcessor {    private static final String OUTDIR_OPTION_FLAG = "-s";    private static final String AUDITFILE_OPTION_FLAG = "-a";    private static final String REPORT_FILE_NAME = "coverage.html";    private static final String DEFAULT_AUDIT_FILE_NAME = "tck-audit.xml";    private final List<SpecReference> references = new ArrayList<SpecReference>();    private AuditParser auditParser;    private File baseDir;    public CoverageProcessor() {    }    public void init(ProcessingEnvironment env) {        super.init(env);        createOutputDir();        InputStream in = getAuditFileInputStream();        if (in == null) {            return;        }        try {            auditParser = new AuditParser(in);            auditParser.parse();        }        catch (Exception e) {            throw new RuntimeException("Unable to parse audit file.");        }    }    private InputStream getAuditFileInputStream() {        InputStream in;        String auditFileName = processingEnv.getOptions().get(AUDITFILE_OPTION_FLAG);        if (auditFileName == null || auditFileName.length() == 0) {            auditFileName = getCurrentWorkingDirectory() + DEFAULT_AUDIT_FILE_NAME;            processingEnv.getMessager().printMessage(                    Diagnostic.Kind.NOTE,                    "No audit file specified on the command line. Trying default: " + auditFileName            );        }        try {            in = new FileInputStream(auditFileName);        }        catch (IOException ex) {            processingEnv.getMessager()                    .printMessage(Diagnostic.Kind.WARNING, "Unable to open audit file - " + auditFileName);            processingEnv.getMessager().printMessage(Diagnostic.Kind.WARNING, "No report generated");            return null;        }        return in;    }    private void createOutputDir() {        String baseDirName = processingEnv.getOptions().get(OUTDIR_OPTION_FLAG);        // I would like to get the baseDir as property, but it seems that the maven compiler plugin still has issues - http://jira.codehaus.org/browse/MCOMPILER-75        if (baseDirName == null) {            baseDirName = getCurrentWorkingDirectory() + "target";            processingEnv.getMessager().printMessage(                    Diagnostic.Kind.NOTE,                    "No output directory specided using " + baseDirName + "instead."            );        }        baseDir = new File(baseDirName);        baseDir.mkdirs();    }    private String getCurrentWorkingDirectory() {        return System.getProperty("user.dir") + System.getProperty("file.separator");    }    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnvironment) {        if (auditParser == null) {            return true;        }        for (TypeElement type : annotations) {            processAnnoatedMethods(roundEnvironment, type);        }        if (roundEnvironment.processingOver()) {            new CoverageReport(references, auditParser).writeToFile(new File(baseDir, REPORT_FILE_NAME));        }        return true;    }    private void processAnnoatedMethods(RoundEnvironment env, TypeElement annotation) {        Set<Element> elements = (Set<Element>) env.getElementsAnnotatedWith(annotation);        for (Element element : elements) {            processMethod(element);        }    }    private void processMethod(Element element) {        ExecutableElement methodElement = (ExecutableElement) element;        String annotationType = null;        for (AnnotationMirror annotationMirror : processingEnv.getElementUtils().getAllAnnotationMirrors(methodElement)) {            Map<? extends ExecutableElement, ? extends AnnotationValue> annotationParameters =                    processingEnv.getElementUtils().getElementValuesWithDefaults(annotationMirror);            annotationType = annotationMirror.getAnnotationType().toString();            if (annotationType.equals(SpecAssertions.class.getName())) {                List<AnnotationMirror> mirrors = (List<AnnotationMirror>) annotationMirror.getElementValues().values().iterator().next().getValue();                for (AnnotationMirror mirror : mirrors) {                    createSpecReference(methodElement, processingEnv.getElementUtils().getElementValuesWithDefaults(mirror));                }            } else if (annotationType.equals(SpecAssertion.class.getName())) {                createSpecReference(methodElement, annotationParameters);            }        }    }    private void createSpecReference(ExecutableElement methodElement, Map<? extends ExecutableElement, ? extends AnnotationValue> annotationParameters) {        SpecReference ref = new SpecReference();        ref.setClassName(methodElement.getClass().getName());        ref.setMethodName(methodElement.getSimpleName().toString());        for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> entry : annotationParameters.entrySet()) {            final String elementKey = entry.getKey().toString();            // TODO - is there no better way of doing this?            if (elementKey.equals("section()")) {                ref.setSection(entry.getValue().toString());            } else if (elementKey.equals("id()")) {                ref.setAssertion(entry.getValue().toString());            }        }        references.add(ref);    }}